#include <U8g2lib.h>
#include <math.h>

static const unsigned char image_framelayer_bits[] U8X8_PROGMEM = {
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
static const unsigned char image_ButtonCenter_bits[] U8X8_PROGMEM = {0x1c,0x22,0x5d,0x5d,0x5d,0x22,0x1c};
static const unsigned char image_degree_bits[] U8X8_PROGMEM = {
0x03,0x00,0xf3,0x00,0x98,0x01,0x08,0x00,0x08,0x00,0x08,0x00,0x98,0x01,0xf0,0x00};
static const unsigned char image_farad_bits[] U8X8_PROGMEM = {
0x03,0x03,0xf8,0x08,0x08,0x78,0x08,0x08,0x08,0x08};
static const unsigned char image_weather_temperature_bits[] U8X8_PROGMEM = {
0x38,0x00,0x44,0x40,0xd4,0xa0,0x54,0x40,0xd4,0x1c,0x54,0x06,0xd4,0x02,0x54,0x02,
0x54,0x06,0x92,0x1c,0x39,0x01,0x75,0x01,0x7d,0x01,0x39,0x01,0x82,0x00,0x7c,0x00};
static const unsigned char image_battery_full_bits[] U8X8_PROGMEM = {
0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x68,0xdb,0xb6,0x6e,0xdb,0xb6,0x61,
0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x6e,0xdb,
0xb6,0x68,0xdb,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_heart1_bits[] U8X8_PROGMEM = {
0x00,0x00,0x00,0x00,0x1c,0x1c,0x3e,0x3e,0x7f,0x7f,0xff,0x7f,0xff,0x7f,0xff,0x7f,
0xfe,0x3f,0xfc,0x1f,0xf8,0x0f,0xf0,0x07,0xe0,0x03,0xc0,0x01,0x80,0x00,0x00,0x00};
static const unsigned char image_heart2_bits[] U8X8_PROGMEM = {
0x1c,0x1c,0x36,0x36,0x62,0x23,0xc3,0x61,0x81,0x40,0x01,0x40,0x01,0x40,0x03,0x60,
0x02,0x20,0x06,0x30,0x04,0x10,0x0c,0x18,0x18,0x0c,0x30,0x06,0x60,0x03,0xc0,0x01};
// OLED setup (I2C example, adjust according to your setup)
// U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE, /* clock=*/ A5, /* data=*/ A4);

// NTC Variables
float TempC, TempF;

// Pulse Sensor Variables
const int pulsePin = A0;        // Pulse sensor signal pin connected to A0
volatile int signalValue = 0;   // Variable to store raw analog readings
volatile unsigned long lastBeatTime = 0;
volatile unsigned long currentTime = 0;
volatile int BPM = 0;
volatile int beatsDetected = 0;
volatile bool pulseDetected = false;

// Timer for display update
unsigned long displayInterval = 1000; // Update every 1 second
unsigned long lastDisplayTime = 0;

// Threshold for pulse detection
const int threshold = 472;

// Switch pin (button or switch to control display of BPM and analog value)
const int switchPin = 2;  // Pin where the switch is connected (use a pull-up resistor)

unsigned long switchPressTime = 0;
bool switchPressed = false;
// bool showImage = false;
bool showHeartAnimation = false;
bool showPressButtonMessage = true;
bool showBPM = false;
bool showAnalog = false;
void setup() {
  Serial.begin(9600);
  pinMode(pulsePin, INPUT);
  pinMode(switchPin, INPUT_PULLUP); // Switch is active LOW, so use internal pull-up
  
  // Initialize OLED display
  u8g2.begin();
  u8g2.setFont(u8g2_font_t0_12b_tr);
// Set font for display
}

// void loop() {
//   // Read temperature
//   TempC = Read_NTC10k();
//   TempF = (TempC * 1.8) + 32.0;

//   // Read the pulse sensor signal
//   signalValue = analogRead(pulsePin);

//   // Detect a pulse
//   if (signalValue > threshold && !pulseDetected) {
//     pulseDetected = true; // Mark pulse detected
//     unsigned long beatInterval = millis() - lastBeatTime;
//     lastBeatTime = millis();

//     if (beatInterval > 300) { // Ignore spurious beats (minimum time between beats)
//       BPM = 60000 / beatInterval;
//       beatsDetected++;
//     }
//   }

//   // Reset pulse detection flag after signal falls below the threshold
//   if (signalValue < threshold) {
//     pulseDetected = false;
//   }

//   // Check if the switch is pressed (active LOW)
//   bool switchState = digitalRead(switchPin) == LOW;

//   // // If the switch is pressed, start the 6-second timer
//   // if (switchState && !switchPressed) {
//   //   switchPressed = true;
//   //   switchPressTime = millis();  // Record the time when switch was pressed
//   //   showImage = true;  // Show image
//   // }
//   // Step 1: If switch is pressed, start 6-second timer and show heart animation
//   if (switchState && !switchPressed) {
//     switchPressed = true;
//     switchPressTime = millis();  // Record the time when switch was pressed
//     showPressButtonMessage = false;  // Hide the "Press Button" message
//     showHeartAnimation = true;  // Start showing the animation
//   }

//   // // If the switch was pressed and 6 seconds have passed, show BPM and analog value
//   // if (switchPressed && showImage) {
//   //   if (millis() - switchPressTime >= 6000) { // After 6 seconds
//   //     showImage = false;  // Stop showing the image
//   //     switchPressed = false; // Reset switch state
      
//   //   }
//   // }
//   // Step 2: If the switch was pressed, show heart animation for 6 seconds
//   if (switchPressed && showHeartAnimation) {
//     if (millis() - switchPressTime < 6000) { // Show animation for 6 seconds
//       // Alternate between heart1 and heart2 for animation
//       if ((millis() / 500) % 2 == 0) {
//     u8g2.drawXBMP(89, 26, 15, 16, image_heart1_bits);
//     u8g2.sendBuffer();
//     delay(1000);
//     // u8g2.clearBuffer();
//     u8g2.drawXBMP(89, 26, 15, 16, image_heart2_bits); // Display the image (8x8 bitmap)
//     u8g2.sendBuffer();
//     delay(1000);
//       }
//     } else {
//       // After 6 seconds, stop the animation and show BPM/analog values
//       showHeartAnimation = false;
//       switchPressed = false;
//     }
//   }
// // Step 3: After 6 seconds, show BPM and analog values
// if (!showHeartAnimation) {
//   // Update the display every second
//   currentTime = millis();
//   if (currentTime - lastDisplayTime >= displayInterval) {
//     lastDisplayTime = currentTime;

//     // Clear the display buffer
//     u8g2.clearBuffer();
//           // Show "Press Button" message if not pressed yet
//       if (showPressButtonMessage) {
//         u8g2.setCursor(70, 30);
//         u8g2.print("Press Button");
//       }
//     // u8g2.setFont(u8g2_font_t0_12b_tr);
//     u8g2.drawStr(23, 8, "Stress Monitor");
//     u8g2.drawXBMP(0, 9, 128, 55, image_framelayer_bits);
//     // u8g2.setFont(u8g2_font_5x8_tr);
//     u8g2.drawStr(2, 18, "Temprature");
//     u8g2.setCursor(20, 29);
//     u8g2.print(TempC, 1);
//     // u8g2.drawStr(10, 29, TempC.c_str());
//     u8g2.drawXBMP(10, 1, 7, 7, image_ButtonCenter_bits);
//     u8g2.drawXBMP(52, 22, 9, 8, image_degree_bits);
//     u8g2.setCursor(20, 43);
//     u8g2.print(TempF, 1);
//     // u8g2.drawStr(10, 43, TempF.c_str());
//     u8g2.drawXBMP(52, 36, 8, 10, image_farad_bits);
//     u8g2.drawXBMP(3, 46, 16, 16, image_weather_temperature_bits);
//     u8g2.drawXBMP(37, 47, 24, 16, image_battery_full_bits);
//     // Always show the temperature
//     // u8g2.setCursor(0, 15);
//     // u8g2.print("Temp: ");
//     // u8g2.print(TempC, 1);
//     // u8g2.print(" C | ");
//     // u8g2.print(TempF, 1);
//     // u8g2.print(" F");

//     // Show the image for 6 seconds when the switch is pressed
//     // if (showImage) {
//     // u8g2.drawXBMP(89, 26, 15, 16, image_heart1_bits);
//     // u8g2.sendBuffer();
//     // delay(1000);
//     // // u8g2.clearBuffer();
//     // u8g2.drawXBMP(89, 26, 15, 16, image_heart2_bits); // Display the image (8x8 bitmap)
//     // u8g2.sendBuffer();
//     // delay(1000);
//     // }

//     // After 6 seconds, display BPM and analog value
//     // if (!showImage) {
//      if (!showPressButtonMessage && !showHeartAnimation) {
//       // u8g2.setCursor(0, 30);
//       // u8g2.print("BPM: ");
//       // u8g2.print(BPM);
//       // u8g2.setCursor(0, 45);
//       // u8g2.print("Analog: ");
//       // u8g2.print(signalValue);
//       // u8g2.setFont(u8g2_font_t0_12b_tr);
//       u8g2.drawStr(80, 18, "-Pulse-");
//       u8g2.drawStr(78, 30, "BPM:");
//       u8g2.setCursor(87, 39);
//       u8g2.print(BPM);
//       // u8g2.drawStr(70, 36, BPM.c_str());
//       u8g2.drawStr(78, 48, "Analog:");
//       u8g2.setCursor(87, 58);
//       u8g2.print(signalValue);
//       // u8g2.drawStr(78, 55, signalValue.c_str());
//     }

//     // Send buffer to OLED display
//     u8g2.sendBuffer();
//   }
// }
// }
// Function to draw the core static display
// Function to draw the core static display
void drawCoreDisplay(float tempC, float tempF) {
    // Core information display
    u8g2.drawStr(23, 8, "Stress Monitor");
    u8g2.drawXBMP(0, 9, 128, 55, image_framelayer_bits);
    u8g2.drawStr(2, 18, "Temprature");
    u8g2.setCursor(20, 29);
    u8g2.print(tempC, 1);
    u8g2.drawXBMP(10, 1, 7, 7, image_ButtonCenter_bits);
    u8g2.drawXBMP(52, 22, 9, 8, image_degree_bits);
    u8g2.setCursor(20, 43);
    u8g2.print(tempF, 1);
    u8g2.drawXBMP(52, 36, 8, 10, image_farad_bits);
    u8g2.drawXBMP(3, 46, 16, 16, image_weather_temperature_bits);
    u8g2.drawXBMP(37, 47, 24, 16, image_battery_full_bits);
}

void loop() {
    // Read temperature
    TempC = Read_NTC10k();
    TempF = (TempC * 1.8) + 32.0;

    // Read the pulse sensor signal
    signalValue = analogRead(pulsePin);

    // Detect a pulse
    if (signalValue > threshold && !pulseDetected) {
        pulseDetected = true;
        unsigned long beatInterval = millis() - lastBeatTime;
        lastBeatTime = millis();

        if (beatInterval > 300) { // Ignore spurious beats
            BPM = 60000 / beatInterval;
            beatsDetected++;
        }
    }

    if (signalValue < threshold) {
        pulseDetected = false;
    }

    // Start with clearing the buffer and drawing the core display
    u8g2.clearBuffer();
    drawCoreDisplay(TempC, TempF);

    // Check if the switch is pressed (active LOW)
    bool switchState = digitalRead(switchPin) == LOW;

    // Step 1: Handle switch press logic
    if (switchState && !switchPressed) {
        switchPressed = true;
        switchPressTime = millis();
        showPressButtonMessage = false;
        showHeartAnimation = true;
    }

    // Step 2: Show heart animation for 6 seconds
    if (switchPressed && showHeartAnimation) {
        if (millis() - switchPressTime < 6000) {
            // Alternate between heart1 and heart2 for animation
            if ((millis() / 500) % 2 == 0) {
                u8g2.drawXBMP(89, 26, 15, 16, image_heart1_bits);
            } else {
                u8g2.drawXBMP(89, 26, 15, 16, image_heart2_bits);
            }
        } else {
            // End heart animation, show BPM and analog
            showHeartAnimation = false;
            showBPM = true;
            switchPressed = false; // Reset switch state
            switchPressTime = millis();
        }
    }

    // Step 3: Show BPM and analog values for 3 seconds
    if (showBPM) {
        if (millis() - switchPressTime < 3000) {
            u8g2.drawStr(80, 18, "-Pulse-");
            u8g2.drawStr(78, 30, "BPM:");
            u8g2.setCursor(87, 39);
            u8g2.print(BPM);
            u8g2.drawStr(78, 48, "Analog:");
            u8g2.setCursor(87, 58);
            u8g2.print(signalValue);
        } else {
            // Reset to show "Press Button" again
            showBPM = false;
            showPressButtonMessage = true;
        }
    }

    // Show "Press Button" message if no other display is active
    if (showPressButtonMessage) {
        u8g2.drawStr(70, 30, "Press");
        u8g2.drawStr(70, 39, "Button");
        u8g2.drawStr(70, 48, "For");
        u8g2.drawStr(70, 57, "Pulse");
    }

    // Send buffer to display
    u8g2.sendBuffer();
}

// Function to calculate temperature from NTC
float Read_NTC10k() {
  float a = 639.5, b = -0.1332, c = -162.5;
  float Rntc, Vntc, Temp;
  Vntc = (analogRead(A1) * 5.0) / 1023.0;
  Rntc = 10000.0 * ((5.0 / Vntc) - 1);
  Temp = a * pow(Rntc, b) + c;
  return Temp;
}
